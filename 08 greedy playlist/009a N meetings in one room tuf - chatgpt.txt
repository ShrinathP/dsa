/*

IMP: Try to take up faster meetings  - meetings with earlier end times

ðŸ§© Problem Summary:
Given n meetings with start[i] and end[i] times.
Only one meeting can be held at a time in a room.
Objective: Maximize the number of non-overlapping meetings.

âœ… Goal:
Schedule maximum number of non-overlapping meetings in one room.

ðŸ’¡ Greedy Choice:
Always pick the meeting that ends earliest.
Why?
- Ending earlier frees up the room for more meetings later.
- This locally optimal choice leads to global maximum.

ðŸ§  Algorithm Steps (Greedy):
1. Input:
Arrays start[] and end[] of n meetings.
2. Create Meeting objects with:
    - start time, end time, and optional position/index.
3. Sort all meetings by end time (ascending): ( if end time is same sort by position )
    - So you always consider the earliest finishing meeting first.
4. Initialize:
- count = 1 â†’ first meeting is always selected.
- lastEnd = end time of first meeting
5. Iterate from the second meeting to the end:
    - For each meeting i, if start[i] > lastEnd:
        - Select this meeting.
        - count++
        - Update lastEnd = end[i]
6. Return count as the max number of non-overlapping meetings.


Time Complexity
O(N) to traverse,+ O(NlogN) to sort, + O(N) to traverse finising
times
Space Complexity O(N)
*/

//Solution
import java.util.*;

class Meeting {
    int start, end, pos;
    Meeting(int start, int end, int pos) {
        this.start = start;
        this.end = end;
        this.pos = pos;
    }
}

public class NMeetings {
    public static int maxMeetings(int[] start, int[] end, int n) {
        List<Meeting> meetings = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            meetings.add(new Meeting(start[i], end[i], i + 1));
        }

        // Sort by end time (if equal, by position)
        meetings.sort((a, b) -> a.end != b.end ? a.end - b.end : a.pos - b.pos);

        //can keep an answer arraylist as well // ArrayList<Integer> answer = new ArrayList<>();
        //adding the first meeting and getting its end
        int count = 1;
        int lastEnd = meetings.get(0).end;

        
        for (int i = 1; i < n; i++) {
            if (meetings.get(i).start > lastEnd) {
                count++;
                lastEnd = meetings.get(i).end;
            }
        }

        return count;
    }

    public static void main(String[] args) {
        int[] start = {1, 3, 0, 5, 8, 5};
        int[] end =   {2, 4, 6, 7, 9, 9};
        int n = start.length;

        System.out.println("Max meetings: " + maxMeetings(start, end, n));
    }
}
