/*
Striver Explanation, google ai code
ðŸ§© Problem Summary:
- There are n children standing in a line, and each child has a rating value.
- You need to distribute candies such that:
  1. Each child gets at least 1 candy.
  2. Children with a higher rating get more candies than their neighbors.
- The task is to find the minimum number of candies required to distribute to the children.

âœ… Greedy Approach:
1. Two passes through the ratings:
  - First pass (left to right): Ensure children with higher ratings get more candies than their left neighbor.
  - Second pass (right to left): Ensure children with higher ratings get more candies than their right neighbor, and adjust the candies from the first pass if necessary.
2. Why two passes?:
  - The first pass ensures that we correctly handle increasing sequences.
  - The second pass ensures that we handle decreasing sequences while adjusting the candies given to children when needed.

TC - O(3N) - 3 for loops
SC - O(2N) - 2 arrays
*/


import java.util.Arrays;

class Solution {
    public int candy(int[] ratings) {
        final int n = ratings.length;
        if (n == 0) {
            return 0; // No children, no candies needed
        }

        // Initialize two arrays to store candy counts based on left and right comparisons
        int[] left = new int[n];
        int[] right = new int[n];

        // Fill both arrays with 1, as each child must receive at least one candy
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);

        // First pass: Left-to-right
        // If current child has a higher rating than the one to their left,
        // they get one more candy than the left neighbor.
        for (int i = 1; i < n; ++i) {
            if (ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }

        // Second pass: Right-to-left
        // If current child has a higher rating than the one to their right,
        // they get one more candy than the right neighbor.
        for (int i = n - 2; i >= 0; --i) {
            if (ratings[i] > ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
        }

        // Calculate the total minimum candies
        int totalCandies = 0;
        for (int i = 0; i < n; ++i) {
            // For each child, the final candy count is the maximum of the
            // candies determined by the left and right passes.
            totalCandies += Math.max(left[i], right[i]);
        }

        return totalCandies;
    }
}
