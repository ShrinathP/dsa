/*
Algorithms made easy explanation and code
Prefix Sum + Binary Search

You are given an array of non-overlapping axis-aligned rectangles rects where 
rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. 
Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. 

x1,y1,x2,y2 - so rects[2] - rects[0] will be width and rects[3] - rects[1] is height
1. Iterate over all rectange
    - Find Total -> add to total
    - Find PrefixSum -> fill it in List
2. In pick method, find Random target with max Value of total (between 0 to total)
    -  use binary search to find the prefixsum closest to the target
    - lo wiill hold the target point
*/


class Solution {

    int[][] rects;
    Random r = new Random();
    int total = 0;
    List<Integer> prefixSum = new ArrayList<>();

    public Solution(int[][] rects) {
        this.rects = rects;
//x1,y1,x2,y2 are the points
        for (int[] rec : rects) {
            total += (rec[2] - rec[0] + 1) * (rec[3] - rec[1] + 1);
            prefixSum.add(total);
        }
    }

    public int[] pick() {
        int target = r.nextInt(total);
        int lo = 0, hi = rects.length - 1;
//find the nearest rectangle number, prefixSum will have rects.length number of prefixSums
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (target >= prefixSum.get(mid))
                lo = mid + 1;
            else
                hi = mid;
        }

        int[] rect = rects[lo];
        int x1 = rect[0], y1 = rect[1];
        int x2 = rect[2], y2 = rect[3];

        int x = r.nextInt(x2 - x1 + 1);
        int y = r.nextInt(y2 - y1 + 1);

        return new int[]{x1 + x, y1 + y};
    }
}


/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(rects);
 * int[] param_1 = obj.pick();
 */
