//NICK White, chatgpt soln

//IMP: Maintain a monotonic decreasing stack
/*
\
  \
    \
      \
IMP: Current element to be pushed has to be the smallest in the stack in order to maintain the monotonic decreasing sequence.
So remove everything which is smaller than the current element


//If the current num is greater than stack peek, we pop the stack, else we keep pushing, hence maintaining the Monotonic decreasing stack
*/

/*
Visualizing the Monotonic Stack:
For example, consider nums2 = [1, 3, 4, 2]:

Step 1: Push 1 onto the stack.
Stack: [1]

Step 2: 3 is greater than 1 (top of stack), so pop 1 and assign 3 as the next greater element for 1. Then push 3 onto the stack.
Stack: [3] (and 1's next greater element is 3)

Step 3: 4 is greater than 3 (top of stack), so pop 3 and assign 4 as the next greater element for 3. Then push 4 onto the stack.

Stack: [4] (and 3's next greater element is 4)
Step 4: 2 is less than 4 (top of stack), so simply push 2 onto the stack.

Stack: [4, 2]
At this point, weâ€™ve processed all elements in nums2, 
and the stack contains [4, 2]. Both 4 and 2 don't have a next greater element, so we leave them as they are.
*/

import java.util.*;

public class NextGreaterElement {
    
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        // Create a map to store the next greater element for each number in nums2
        Map<Integer, Integer> nextGreaterMap = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        
        // Traverse nums2 and populate the nextGreaterMap using the stack
        for (int num : nums2) {
            // Pop elements from the stack while the current element is greater than the stack's top element
            // and save to the nextgreatermap
            while (!stack.isEmpty() && stack.peek() < num) {
                nextGreaterMap.put(stack.pop(), num);  // The next greater for the popped element is the current number
            }
            stack.push(num);  // Push the current element to the stack
        }
        
        // Now traverse nums1 and find the next greater element for each
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreaterMap.getOrDefault(nums1[i], -1);  // If no next greater element, return -1
        }
        
        return result;
    }

    // Test the solution
    public static void main(String[] args) {
        NextGreaterElement solution = new NextGreaterElement();
        
        int[] nums1 = {4, 1, 2};
        int[] nums2 = {1, 3, 4, 2};
        
        int[] result = solution.nextGreaterElement(nums1, nums2);
        
        System.out.println(Arrays.toString(result));  // Output: [3, -1, -1]
    }
}
