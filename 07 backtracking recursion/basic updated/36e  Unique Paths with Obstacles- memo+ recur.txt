/*
Down or Right Movements only allowed
	Only ↓ and →

✅ Problem Summary:
Given a 2D grid obstacleGrid[][]:
  0 = open cell
  1 = obstacle  
  Find the number of unique paths from top-left (0,0) to bottom-right (m-1,n-1) moving only right or down.

Note: there is a DP version as well
*/

class Solution {
    public int uniquePathsWithObstacles(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] memo = new int[m][n];

        // Initialize memo with -1 (uncomputed)
        for (int[] row : memo) Arrays.fill(row, -1);

        return dfs(0, 0, grid, memo);
    }

    private int dfs(int row, int col, int[][] grid, int[][] memo) {
        int m = grid.length, n = grid[0].length;

        // Out of bounds or obstacle
        if (row >= m || col >= n || grid[row][col] == 1) return 0;

        // Reached destination
        if (row == m - 1 && col == n - 1) return 1;

        // Already computed
        if (memo[row][col] != -1) return memo[row][col];

        // Store and return result
        memo[row][col] = dfs(row + 1, col, grid, memo) + dfs(row, col + 1, grid, memo);
        return memo[row][col];
    }
}
