/*

Skip duplicates logic Explanation
if (i > index && nums[i] == nums[i - 1]) continue;

remeber this as a formula for duplicates 
if(i>idx&&nums[i]==nums[i-1]) continue; 
place in the starting of the loop and you will fine. 
the whole tricks lies arounds not picking the same element at the same level

*/

Suppose we have a sorted array, for the same level we pick everything
Then at subsequent combinations of the same level we start skipping
     

âœ… Sorted array:
[1, 2, 2]

** RECURSION TREE

Call: index = 0, path = []
â””â”€ i = 0 (nums[0] = 1) âœ… include
   â””â”€â”€ path = [1], index = 1
       â”œâ”€ i = 1 (nums[1] = 2) âœ… include
       â”‚   â””â”€â”€ path = [1,2], index = 2
       â”‚       â”œâ”€ i = 2 (nums[2] = 2) âœ… include
       â”‚       â”‚   â””â”€â”€ path = [1,2,2], index = 3 â†’ âœ… add to result
       â”‚       â””â”€â”€ backtrack
       â””â”€ i = 2 (nums[2] = 2) ðŸ”¥ skip
           â†³ Because:
             - `i = 2`, `index = 1`
             - `nums[2] == nums[1]` âœ… duplicate
             - `i > index` âœ… same level â†’ **SKIP**
       â””â”€â”€ backtrack

Call: index = 0, path = []
â””â”€ i = 1 (nums[1] = 2) âœ… include
   â””â”€â”€ path = [2], index = 2
       â”œâ”€ i = 2 (nums[2] = 2) âœ… include
       â”‚   â””â”€â”€ path = [2,2], index = 3 â†’ âœ… add to result
       â””â”€â”€ backtrack

Call: index = 0, path = []
â””â”€ i = 2 (nums[2] = 2) ðŸ”¥ skip
    â†³ Because:
      - `i = 2`, `index = 0`
      - `nums[2] == nums[1]` âœ… duplicate
      - `i > index` âœ… same level â†’ **SKIP**


âœ… Final Result:
    []
    [1]
    [1, 2]
    [1, 2, 2]
    [2]
    [2, 2]


ðŸ” Summary of Skip Logic:
Only skip when:
- Duplicate value: nums[i] == nums[i-1]
- At same recursive level: i > index
This prevents duplicate branches like multiple [1,2] or [2,2].


