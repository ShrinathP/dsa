//leetcode - 327 - Count of Range Sum
//chatgpt solution 
// explanation
/*

1. Define prefix sums: pre[k] = nums[0] + nums[1] ...nums[k-1]
any subarray sum is:
sum(i..j) = pre[j+1] - pre[i]
We want to count pairs (i, j)
Such that - 
lower ≤ pre[j] - pre[i] ≤ upper
Rearranged above
pre[j] - upper ≤ pre[i] ≤ pre[j] - lower
2. During merge sort
For every pre[j] in right half, find the min max range in left half
We use two sliding pointers lo and hi:
lo moves until pre[lo] >= pre[j] - upper
hi moves until pre[hi] > pre[j] - lower
3. Add hi - lo to the count
4. Merge function same as - Count of Smaller numbers after self

*/

class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        long[] pre = new long[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }
        return mergeSort(pre, 0, pre.length - 1, lower, upper);
    }

    private int mergeSort(long[] pre, int left, int right, int lower, int upper) {
        if (left >= right) return 0;

        int mid = left + (right - left) / 2;
        int count = 0;

        count += mergeSort(pre, left, mid, lower, upper);
        count += mergeSort(pre, mid + 1, right, lower, upper);

        // Count valid pairs across halves
        count += countWhileMerging(pre, left, mid, right, lower, upper);

        // Standard merge to keep prefix array sorted
        merge(pre, left, mid, right);

        return count;
    }

    private int countWhileMerging(long[] pre, int left, int mid, int right,
                                  int lower, int upper) {

        int count = 0;
        int lo = left, hi = left;

        for (int j = mid + 1; j <= right; j++) {
            long minVal = pre[j] - upper;
            long maxVal = pre[j] - lower;

            // Move lo until pre[lo] >= minVal
            while (lo <= mid && pre[lo] < minVal) lo++;

            // Move hi until pre[hi] > maxVal
            while (hi <= mid && pre[hi] <= maxVal) hi++;

            count += (hi - lo);
        }

        return count;
    }

    private void merge(long[] arr, int left, int mid, int right) {
        long[] temp = new long[right - left + 1];
        int i = left, j = mid + 1, k = 0;

        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) temp[k++] = arr[i++];
            else temp[k++] = arr[j++];
        }
        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];

        System.arraycopy(temp, 0, arr, left, temp.length);
    }
}
