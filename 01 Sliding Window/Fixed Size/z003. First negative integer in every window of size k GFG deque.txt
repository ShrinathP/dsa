
//GFG deque
//Time complexity O(n) and O(k) space complexity as we are holding in Deque

//Explanation
//Yogesh & Shailesh (CodeLibrary)
//Solution chatgpt
/*
Problem Summary:
We need to find the first negative number in every sliding window of size K in an array of integers. If there's no negative number in a window, we return 0 for that window.

ðŸ§  Key Idea:
Use a queue to store the indices of negative numbers in the current window of size K.
As we slide the window, the queue helps us efficiently keep track of the first negative number in each window.

ðŸ§  Algorithm Explanation:
1. Deque to Store Indices of Negative Numbers:
    - The deque is used to store the indices of negative numbers in the current window of size k.
    - We keep the first negative number's index at the front of the deque, ensuring we can quickly retrieve the first negative number for each window.

2. Sliding Window:
    - We move through the array, starting from index 0 to n-1.
    - For each element:
        - If it's negative, add its index to the back of the deque.
        - If the index of the first element in the deque is out of the current window (i - k), remove it from the deque.
    - After processing each window, if thereâ€™s at least one negative number, we add the first negative number (i.e., the element at the front of the deque) to the result list.
    - If the deque is empty (no negative numbers in the current window), we add 0 to the result list

3. Sliding the Window:
    - The window starts from index 0 and slides by incrementing the index.
    - After reaching index k-1, we start adding the first negative number in the current window (or 0 if thereâ€™s no negative number).
*/

import java.util.*;

public class FirstNegativeInWindow {

    public static List<Integer> firstNegativeInWindow(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new ArrayDeque<>(); // stores indices of negative numbers

        int n = arr.length;
        for (int i = 0; i < n; i++) {
            // Add current element's index if it's negative
            if (arr[i] < 0) {
                deque.addLast(i);
            }

            // Remove indices that are out of the current window
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }

            // Start adding results after first k elements
            if (i >= k - 1) {
                if (!deque.isEmpty()) {
                    result.add(arr[deque.peekFirst()]);
                } else {
                    result.add(0); // no negative number in this window
                }
            }
        }

        return result;
    }

    // Test
    public static void main(String[] args) {
        int[] arr = {12, -1, -7, 8, 15, 30, 16, 28};
        int k = 3;
        List<Integer> result = firstNegativeInWindow(arr, k);
        System.out.println(result);  // Output: [-1, -1, -7, 0, 0, 0]
    }
}

