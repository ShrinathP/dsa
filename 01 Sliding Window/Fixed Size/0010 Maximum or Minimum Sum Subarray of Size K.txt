/*
Problem Statement:
Given an array of integers arr and an integer k representing the desired subarray size, the task is to find:
1. Maximum Sum Subarray of Size K:
The maximum sum among all subarrays of arr that have a length of exactly k.
2. Minimum Sum Subarray of Size K:
The minimum sum among all subarrays of arr that have a length of exactly k.
3. Start index of the Maximum Sum Subarray of Size K
*/

public class SubarraySizeK {

    //1. Max sum of any contiguous subarray of size k
    public static int maxSumOfSizeK(int[] a, int k) {
        if (a == null || k <= 0 || k > a.length) throw new IllegalArgumentException();
        int windowSum = 0;
        
        // Calculate the sum of the first window
        for (int i = 0; i < k; i++) windowSum += a[i];
        int maxSum = windowSum; // Initialize maxSum with the first window's sum

        // Slide the window across the array
        for (int r = k; r < a.length; r++) {
            windowSum += a[r] - a[r - k];   // add right new element, remove left element
            if (windowSum > maxSum) maxSum = windowSum; // Update maxSum if current sum is greater
        }
        return maxSum;
    }

    //2. Min sum of any contiguous subarray of size k
    public static int minSumOfSizeK(int[] a, int k) {
        if (a == null || k <= 0 || k > a.length) throw new IllegalArgumentException();
        int windowSum = 0;
        for (int i = 0; i < k; i++) windowSum += a[i];
        int minSum = windowSum;

        for (int r = k; r < a.length; r++) {
            windowSum += a[r] - a[r - k];
            if (windowSum < minSum) minSum = windowSum;
        }
        return minSum;
    }

    //3. (Optional) return start index of max-sum window
    public static int maxSumStartIndex(int[] a, int k) {
        if (a == null || k <= 0 || k > a.length) throw new IllegalArgumentException();
        int windowSum = 0;
        for (int i = 0; i < k; i++) windowSum += a[i];
        int maxSum = windowSum, start = 0;

        for (int r = k; r < a.length; r++) {
            windowSum += a[r] - a[r - k];
            // while updating maxSum, update start index as well
            if (windowSum > maxSum) { maxSum = windowSum; start = r - k + 1; }
        }
        return start;
    }
}
