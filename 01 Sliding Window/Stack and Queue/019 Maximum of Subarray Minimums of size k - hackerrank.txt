/*
HACKERRANK QUESTION
Problem Statement: Maximum of Subarray Minimums with Subarray Size k
Given an array of integers, you need to find the maximum of the minimums of all subarrays of size k.

More formally:
For each subarray of size k, find the minimum element in that subarray. After finding the minimums for all subarrays, return the maximum of those minimums.

Input:
An integer array A of size n where n is the length of the array.
An integer k representing the size of the subarrays.

Output:
A single integer representing the maximum of the minimums of all subarrays of size k.

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
monotonic increasing deque

To find the minimum of a sliding window, 
we need a monotonic increasing deque, where the smallest element will always be at the front of the deque.

Maintaining the smallest element: In a monotonic increasing deque, 
the front of the deque always gives us the minimum element in the window because elements in the stack are arranged in increasing order from back to front.

If for a current element,
  - queue elements are greater than the current 
  - keep removing elements from the queue

*/


import java.util.*;

public class MaximumOfSubarrayMinimums {

    public int maxSumOfSubarrayMins(int[] A, int k) {
        int MOD = 1000000007;
        int n = A.length;
        long result = 0;

        // Deque to store indices for the current sliding window (monotonic increasing stack)
        Deque<Integer> deque = new LinkedList<>();

        // Initial loop to process the first k elements
        for (int i = 0; i < k; i++) {
            // Remove elements from the back of the deque while they are greater than or equal to the current element
            while (!deque.isEmpty() && A[deque.peekLast()] >= A[i]) {
                deque.pollLast(); // Remove elements that are greater or equal to the current element
            }
            deque.offerLast(i); // Add current element's index to the deque
        }

        // Add the minimum of the first window to the result
        result += A[deque.peekFirst()];

        // Now process the remaining elements in the array starting from index k
        for (int i = k; i < n; i++) {
            // Remove elements from the deque that are out of the current window
            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }

            // Remove elements from the deque that are greater than or equal to the current element
            while (!deque.isEmpty() && A[deque.peekLast()] >= A[i]) {
                deque.pollLast();
            }

            // Add the current element to the deque
            deque.offerLast(i);

            // The minimum of the current sliding window is at the front of the deque
            result = (result + A[deque.peekFirst()]) % MOD;
        }

        return (int) result;
    }

    // Test the solution
    public static void main(String[] args) {
        MaximumOfSubarrayMinimums solution = new MaximumOfSubarrayMinimums();

        int[] arr = {3, 1, 2, 4, 6};
        int k = 3;

        int result = solution.maxSumOfSubarrayMins(arr, k);

        System.out.println(result);  // Output: 17
    }
}
