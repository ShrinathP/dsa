// Similar to 11a solution - chatgpt solution
// BFS Using Boundary Queue Initialization

/*
Queue Initialization: By enqueueing all the boundary 'O' cells first, 
we ensure that only the 'O' cells connected to the boundary are explored. 
This minimizes the number of BFS calls and makes the algorithm more efficient.

Single BFS Call: Instead of calling BFS for each boundary 'O' cell separately, 
we only process the queue once, saving redundant calls.
*/


import java.util.*;

class Solution {
    static void bfs(int row, int col, int vis[][], char mat[][], int delRow[], int delCol[]) {
        int m = mat.length;
        int n = mat[0].length;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{row, col});
        vis[row][col] = 1;

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int r = current[0], c = current[1];

            // check for top, right, bottom, left
            for (int i = 0; i < 4; i++) {
                int nRow = r + delRow[i];
                int nCol = c + delCol[i];

                if (nRow >= 0 && nRow < m && nCol >= 0 && nCol < n && vis[nRow][nCol] == 0 && mat[nRow][nCol] == 'O') {
                    queue.offer(new int[]{nRow, nCol});
                    vis[nRow][nCol] = 1;
                }
            }
        }
    }

    static char[][] fill(int n, int m, char mat[][]) {
        int delRow[] = {-1, 0, 1, 0};
        int delCol[] = {0, 1, 0, -1};
        int vis[][] = new int[n][m];
        Queue<int[]> queue = new LinkedList<>();

        // Enqueue all 'O' cells from the first and last row and column
        for (int j = 0; j < m; j++) {
            if (mat[0][j] == 'O' && vis[0][j] == 0) {
                queue.offer(new int[]{0, j});
                vis[0][j] = 1;
            }
            if (mat[n - 1][j] == 'O' && vis[n - 1][j] == 0) {
                queue.offer(new int[]{n - 1, j});
                vis[n - 1][j] = 1;
            }
        }

        for (int i = 0; i < n; i++) {
            if (mat[i][0] == 'O' && vis[i][0] == 0) {
                queue.offer(new int[]{i, 0});
                vis[i][0] = 1;
            }
            if (mat[i][m - 1] == 'O' && vis[i][m - 1] == 0) {
                queue.offer(new int[]{i, m - 1});
                vis[i][m - 1] = 1;
            }
        }

        // Perform BFS for all boundary 'O' cells initially enqueued
        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            bfs(current[0], current[1], vis, mat, delRow, delCol);
        }

        // Mark all unvisited 'O' as 'X'
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (vis[i][j] == 0 && mat[i][j] == 'O') {
                    mat[i][j] = 'X';
                }
            }
        }

        return mat;
    }
}
