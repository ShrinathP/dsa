/*
Flood fill algorithm - gfg question
https://www.geeksforgeeks.org/dsa/flood-fill-algorithm/
Striver Explanation and Code

You are given a 2D grid image[][], where each image[i][j] represents the color of a pixel in the image. 
Also provided is a coordinate(sr, sc) representing the starting pixel (row and column) and a new color value newColor.

Your task is to perform a flood fill starting from the pixel (sr, sc), 
changing its color and the color of all connected pixels that have the same original color. 
Two pixels are considered connected if they are adjacent horizontally or vertically (not diagonally) and have the same original color.

Step-by-Step Implementation :
- Store the original color at the starting pixel (sr, sc) as this will help in identifying which connected pixels need to be changed..
- Define a DFS function that takes the current pixel's row and column as parameters.
- In the DFS function, if the current pixel is out of bounds or doesn't match the original color, return (backtrack); otherwise, update its color to newColor and continue the recursion.
- Recursively call DFS for all four adjacent directions:
  - Up: (row - 1, col), Down: (row + 1, col), Left: (row, col - 1), Right: (row, col + 1)
- Start DFS from the starting pixel (sr, sc).
- Once DFS completes, return the updated image.

Time Complexity: O(m * n), where m and n are the dimensions of the image, as each pixel is visited once.
Space Complexity: O(m * n), due to the recursion stack in the worst case of all pixels being connected.
*/

import java.util.*;

class GfG {

    // Helper method for DFS traversal
    static void dfs(int[][] image, int x, int y, 
                        int oldColor, int newColor){

        // Base case: check for out-of-bound indices or mismatched color
        if (x < 0 || x >= image.length || 
            y < 0 || y >= image[0].length || 
            image[x][y] != oldColor) {
            return; // Backtrack if invalid
        }

        // Change the color of the current pixel
        image[x][y] = newColor;

        // Recursively call DFS in all four directions
        dfs(image, x + 1, y, oldColor, newColor); 
        dfs(image, x - 1, y, oldColor, newColor);
        dfs(image, x, y + 1, oldColor, newColor); 
        dfs(image, x, y - 1, oldColor, newColor); 
        
    }

    // Main function to perform flood fill
    static int[][] floodFill(int[][] image, int sr, int sc, int newColor){

        // If the starting pixel already has the new color, no need 
        // to process
        if (image[sr][sc] == newColor) {
            return image;
        }

        // Call DFS with the original color of the starting pixel
        dfs(image, sr, sc, image[sr][sc], newColor);

        // Return the updated image
        return image;
    }

    // Driver code to test the flood fill function
    public static void main(String[] args) {

        // Define the image matrix
        int[][] image = {
            {1, 1, 1, 0},
            {0, 1, 1, 1},
            {1, 0, 1, 1}
        };

        // Starting pixel and the new color
        int sr = 1, sc = 2, newColor = 2;

        // Perform flood fill
        int[][] result = floodFill(image, sr, sc, newColor);

        for (int[] row : result) {
            for (int pixel : row) {
                System.out.print(pixel + " ");
            }
            System.out.println();
        }
    }
}
