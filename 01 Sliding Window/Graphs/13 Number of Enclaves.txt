/*
Number Of Enclaves
You are given an n x m binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.
A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.
Find the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.

Striver Explanation
Chatgpt solution

Enqueue everything at once
Multi Source BFS
*/



import java.util.*;

class Solution {
    // Directions for 4 possible moves (Up, Right, Down, Left)
    static int[] delRow = {-1, 0, 1, 0};
    static int[] delCol = {0, 1, 0, -1};

    // Helper function for BFS
    static void bfs(Queue<int[]> queue, int[][] vis, int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int r = current[0], c = current[1];

            // Explore all 4 directions
            for (int i = 0; i < 4; i++) {
                int nRow = r + delRow[i];
                int nCol = c + delCol[i];

                // Check bounds and if the cell is land ('1') and not visited
                if (nRow >= 0 && nRow < m && nCol >= 0 && nCol < n 
                    && grid[nRow][nCol] == 1 && vis[nRow][nCol] == 0) {
                    queue.offer(new int[]{nRow, nCol});
                    vis[nRow][nCol] = 1;
                }
            }
        }
    }

    // Main function to count number of enclaves
    public int numEnclaves(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] vis = new int[m][n]; // To track visited cells
        Queue<int[]> queue = new LinkedList<>();

        // Enqueue all 'O' cells from the boundary (first and last row and column)
        // First and last row
        for (int j = 0; j < n; j++) {
            if (grid[0][j] == 1 && vis[0][j] == 0) {
                queue.offer(new int[]{0, j});
                vis[0][j] = 1;
            }
            if (grid[m - 1][j] == 1 && vis[m - 1][j] == 0) {
                queue.offer(new int[]{m - 1, j});
                vis[m - 1][j] = 1;
            }
        }

        // First and last column (excluding corners already handled by rows)
        for (int i = 1; i < m - 1; i++) {
            if (grid[i][0] == 1 && vis[i][0] == 0) {
                queue.offer(new int[]{i, 0});
                vis[i][0] = 1;
            }
            if (grid[i][n - 1] == 1 && vis[i][n - 1] == 0) {
                queue.offer(new int[]{i, n - 1});
                vis[i][n - 1] = 1;
            }
        }

        // Perform BFS for all boundary 'O' cells initially enqueued
        bfs(queue, vis, grid);

        // Count the remaining land cells ('1') which are not connected to the boundary
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1 && vis[i][j] == 0) {
                    count++;
                }
            }
        }

        return count; // Number of enclaves
    }
}
