/*
Striver explanation and code from tuf
https://takeuforward.org/data-structure/topological-sort-algorithm-dfs-g-21/

NOTE: Should be acyclic graph - otherwise topological sort is not possible

Problem Statement: Given a Directed Acyclic Graph (DAG) with V vertices and E edges, 
Find any Topological Sorting of that Graph.
Note: In topological sorting, node u will always appear before node v if there is a directed edge from node u towards node v(u -> v).
Linear ordering of vertices such that if there is an edge between u and v
u appears before v in that ordering

As you traverse any element whose dfs is completed, put it in stack, 
As you pop from the stack u will be before v

Since we are inserting the nodes into the stack after the completion of the traversal, 
we are making sure, 
there will be no one who appears afterward but may come before in the ordering 
as everyone during the traversal would have been inserted into the stack. 

Note: Points to remember, that node will be marked as visited immediately after making the DFS call
and before returning from the DFS call, the node will be pushed into the stack.
*/

import java.util.*;

class Solution {
    private static void dfs(int node, int vis[], Stack<Integer> st,
            ArrayList<ArrayList<Integer>> adj) {
        
        //inside the dfs, mark vis array as 1
        //run dfs for every adjacency node
        //once dfs is run mark the node to stack
        vis[node] = 1;
        for (int it : adj.get(node)) {
            if (vis[it] == 0)
                dfs(it, vis, st, adj);
        }
        st.push(node);
    }

    // Function to return list containing vertices in Topological order.
    static int[] topoSort(int V, ArrayList<ArrayList<Integer>> adj) {
        int vis[] = new int[V];
        //maintain a stack
        Stack<Integer> st = new Stack<Integer>();
        //for every visited array element run a dfs
        
        for (int i = 0; i < V; i++) {
            if (vis[i] == 0) {
                dfs(i, vis, st, adj);
            }
        }

        //empty the stack, to get the answer
        int ans[] = new int[V];
        int i = 0;
        while (!st.isEmpty()) {
            ans[i++] = st.peek();
            st.pop();
        }
        return ans;
    }
}

public class tUf {
    public static void main(String[] args) {
        int V = 6;
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }
        adj.get(2).add(3);
        adj.get(3).add(1);
        adj.get(4).add(0);
        adj.get(4).add(1);
        adj.get(5).add(0);
        adj.get(5).add(2);

        int[] ans = Solution.topoSort(V, adj);
        for (int node : ans) {
            System.out.print(node + " ");
        }
        System.out.println("");
    }
}
